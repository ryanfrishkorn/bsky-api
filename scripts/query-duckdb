#!/usr/bin/env bash

# DuckDB Query Notes

set -eo pipefail

DATABASE="${HOME}/.jetstream.duckdb"
OUTPUT_LIST=0 # false
VERBOSE=0 # false
declare -a ARGS

# Script Function List
usage() {
    printf "global options:\n"
    printf "  --db         <file.duckdb>  Specify database to use\n"
    printf "  --help                      This message\n"
    printf "  --list                      Print output in list format\n"
    printf "  --verbose, v                Verbose output\n"
    printf "\n"
    printf "subcommands:\n"
    printf "  common-terms                Show most common terms and stats from FTS index\n"
    printf "  distribution <term>         Show dids and corresponding ordered match counts\n"
    printf "    --start    <'24 hours'>   Set relative start time\n"
    printf "  histogram    <term>         Create histogram for supplied term\n"
    printf "    --start    <'24 hours'>   Set relative start time\n"
    printf "    --interval <'1 hour'>     Set bucket interval size\n"
    printf "    --limit    <n>            Exclude accounts with more than <n> matching posts since start\n"
    printf "  reputation   <did>          Calculate reputation score for did based on post uniquness\n"
    printf "  search       <term>         Search for posts using FTS match for term\n"
    printf "    --limit <n>               Limit results of search query\n"
    printf "    --time                    Sort results by timestamp\n"
    exit 1
}

# Functions

# Require argument $1 or exit
require_arg() {
    if [[ -z $1 ]]; then
        printf "required argument missing\n" 1>&2
        exit 1
    fi
    return 0
}

# Execute duckdb query
run_query() {
    declare -a cmd
    local query

    query=$1
    require_arg "$query"

    # prepend timezone set
    query="$(printf "set time zone 'UTC'; %s" "$query")"
    # query="$(printf "%s" "$query")"

    cmd+=(duckdb -readonly)
    # optional list output
    if ((OUTPUT_LIST)); then
        cmd+=(-list)
    else
        # default json output
        cmd+=(-json)
    fi
    cmd+=("$DATABASE")

    # use jq if json output
    if ((OUTPUT_LIST)); then
        "${cmd[@]}" < <(printf "%s\n" "$query")
    else
        # use jq for compact single-line item format
        jq -c '.[]' < <("${cmd[@]}" < <(printf "%s\n" "$query"))
    fi
}

# Subcommands

# Show most common stems using fts index
common-terms() {
    local query

    read -r -d '' query <<-SQL || true
        select count, s.termid, t.term
        from (
            select count() as count,
            termid from fts_main_posts.terms
            group by termid
        ) as s
        inner join fts_main_posts.dict as t
        on t.termid = s.termid
        order by count desc
        limit 40;
SQL

    run_query "$query"
}

distribution() {
    local start; start="24 hours"
    local term
    local query
    declare -a args

    while (($# > 0)); do
        case $1 in
            --start)
                start=$2
                shift 2
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    term=${args[0]}
    require_arg "$term"

    read -r -d '' query <<-SQL || true
        select did, count(*) as count
        from posts
        where created_at >= now() - interval '$start'
            and created_at < now()
            and text ilike '% ${term} %'
        group by did
        order by count
SQL

    if ((VERBOSE)); then
        printf "%s\n" "$query"
    fi
    run_query "$query"
}

histogram() {
    local start; start="24 hours"
    local interval; interval="1 hour"
    local match_limit; match_limit=10000 # large number default
    local term
    local query
    declare -a args

    while (($# > 0)); do
        case $1 in
            --limit)
                match_limit=$2
                shift 2
                ;;
            --start)
                start=$2
                shift 2
                ;;
            --interval)
                interval=$2
                shift 2
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    term=${args[0]}
    require_arg "$term"

    read -r -d '' query <<-SQL || true
        with matching_posts as (
            select *
            from posts
            where created_at >= now() - interval '$start'
                and created_at < now()
                and text ilike '% ${term} %'
        ), did_exclude as (
            select did, count(*) as exclude_count
            from matching_posts
            group by did
        )
        select time_bucket(interval '$interval', created_at) as bucket,
            '$term' as term,
            count(*) as msg_count
        from matching_posts
        where did not in (
            select did
            from did_exclude
            -- exclude accounts beyond this limit to avoid spam
            where exclude_count > '$match_limit'
        )
        group by bucket
        order by bucket;
SQL

    if ((VERBOSE)); then
        printf "%s\n" "$query"
    fi
    run_query "$query"
}

reputation() {
    local did
    local query
    declare -a args

    while (($# > 0)); do
        case $1 in
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    did="${args[0]}"
    require_arg "$did"

    # did = 'did:plc:dczjtzougy3jlyuwaclw4flv'
    read -r -d '' query <<-SQL || true
        with all_posts as (
            select count(*) as count, text
            from posts where did = '$did'
            group by text
        )
        select '$did' as did, count, text
        from all_posts
        order by count
SQL

    run_query "$query"
}

# Use FTS match for supplied term
search() {
    local term # $1
    local exclude_rate_per_hour ; exclude_rate_per_hour=10
    local interval_hours ; interval_hours='24'
    local limit ; limit=10000
    local order_clause
    local query
    local sort_time ; sort_time=0
    declare -a args

    while (( $# > 0 )); do
        case $1 in
            --hours)
                interval_hours=$2
                shift 2
                ;;
            --limit)
                limit=$2
                shift 2
                ;;
            --time)
                shift
                sort_time=1
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    term="${args[0]}"
    require_arg "$term"

    if ((sort_time)); then
        order_clause="order by ts desc"
    else
        order_clause="order by score desc"
    fi

    read -r -d '' query <<-SQL || true
        with matches as (
            select
                created_at,
                substr(fts_main_posts.match_bm25(cid, '$term', fields := 'text', k := 1.2, b := 0.75, conjunctive := 1)::VARCHAR, 0, 8) as score,
                did,
                text
            from posts
            where score not null
        ),
        posts_window as (
            select * from matches
            where created_at > now()::TIMESTAMP - interval '$interval_hours hours'
                and created_at < now()
        ),
        filtered as (
            select * from posts_window
            where did not in (
                select did from (
                    select did, count(*) as count
                    from posts_window
                    where created_at > now()::TIMESTAMP - INTERVAL '$interval_hours hours'
                        and created_at < now()::TIMESTAMP
                    group by did
                )
                where count > ($interval_hours * $exclude_rate_per_hour) / $interval_hours
            )
        ),
        formatted as (
            select
                substr(created_at::VARCHAR, 0, 17) as ts,
                substr(score::VARCHAR, 0, 8) as score,
                substr(did, 9) as did,
                text
            from filtered
        )
        select * from formatted
        $order_clause
        limit $limit;
SQL

#     read -r -d '' query <<-SQL || true
#     select
#         substr(created_at::VARCHAR, 0, 17) as ts,
#         substr(fts_main_posts.match_bm25(cid, '$term', fields := 'text', k := 1.2, b := 0.75, conjunctive := 1)::VARCHAR, 0, 8) as score,
#         substr(did, 9) as did,
#         text
#     from posts
#     where score not null
#     and created_at > now()::TIMESTAMP - interval '24 hours'
#     $order_clause
#     limit $limit;
# SQL

    run_query "$query"
}

# Function Invocations

# Check options
while (($# > 0)); do
    case $1 in
        --help|-h)
            shift
            usage
            ;;
        --db)
            DATABASE=$2
            shift 2
            ;;
        --list)
            shift
            OUTPUT_LIST=1
            ;;
        -v|--verbose)
            shift
            VERBOSE=1
            ;;
        *)
            ARGS+=("$1")
            shift
            ;;
    esac
done

# require subcommand
if ((${#ARGS[@]} < 1)); then
    usage
fi

# invoke corresponding function
"${ARGS[@]}"
