#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME=$(basename "$0")

require_bin() {
    if which "${1}" >/dev/null; then
        return 0
    fi
    printf "missing binary: %s\n" "${1}"
    exit 1
}

require_file() {
    # one argument only
    if [[ $# != 1 ]]; then
        printf "%s: supply a single file argument\n" "${0}"
        exit 1
    fi
    
    # check file existence
    if [[ -f "${1}" ]]; then
        return 0
    fi
    printf "file not found: %s\n" "${1}"
    exit 1
}

require_no_file() {
    if [[ -f "${1}" ]]; then
        printf "file already exists: %s\n" "${1}"
        exit 1
    fi
    return 0
}

build_from_sqlite() {
    local data_source
    local duckdb_dest
    declare -a cmd

    duckdb_dest=$1
    data_source=$2

    # create schema
    read -r -d '' create_query <<-SQL || true
        create table if not exists posts (did VARCHAR, cid VARCHAR UNIQUE, created_at TIMESTAMPTZ, text VARCHAR);
SQL
    # cmd=(duckdb "$duckdb_dest")
    # "${cmd[@]}" < <(printf "%s" "$create_query")

    cmd=(duckdb)

    read -r -d '' build_query <<-SQL || true
        create temporary table posts_tmp as
        select * from read_parquet('$data_source');

        -- open destination database and ensure schema
        attach '$duckdb_dest' as db_new;
        create table if not exists db_new.posts (created_at TIMESTAMP, cid VARCHAR UNIQUE, did VARCHAR, text VARCHAR);

        -- extract and cast all data
        with parsed as (
            select
                json_extract_string(feedpost, '$.createdAt')::TIMESTAMP as created_at,
                cid::VARCHAR as cid,
                did::VARCHAR as did,
                json_extract_string(feedpost, '$.text')::VARCHAR as text,
                json_extract_string(feedpost, '$.langs') as langs
            from posts_tmp
        )
        insert or ignore into db_new.posts
            select created_at, cid, did, text from parsed
                where langs = '["en"]';
        detach db_new;
SQL

    # and (
    #     json_extract(feedpost, '$.langs') = '["en"]'
    #     or json_extract(feedpost, '$.langs') = ''
    #     or json_extract(feedpost, '$.langs') is null
    # )

    "${cmd[@]}" < <(printf "%s" "$build_query")
}

file_info() {
    for f in "$@"; do
        printf "%s %s bytes\n" "${f}" "$(stat -c "%s" "${f}")"
    done
}

# create fts index
fts_index() {
    local file_duck
    local cmd
    file_duck=$1

    cmd=$(printf "pragma create_fts_index(posts, cid, text, stemmer = 'porter', stopwords = 'english', ignore = '(\\.|[^a-z])+', strip_accents = 1, lower = 1, overwrite = 1)")
    duckdb "${file_duck}" "${cmd}" &> /dev/null
}

# drop existing fts index
fts_drop() {
    local file_duck
    file_duck=$1

    duckdb "${file_duck}" "pragma drop_fts_index(posts)"
}

usage() {
    printf "%s <output.duckdb> <input.parquet> ...\n" "${SCRIPT_NAME}"
    printf "  --append  Append to existing duck database\n"
    exit 1
}

# Begin script logic

# check for help args
for arg in "$@"; do
    if [[ "${arg}" == "--help" ]] || [[ "${arg}" == "-h" ]]; then
        usage
    fi
done

declare -a args
append=1    ; cfg_append()    { return $append; }    # default false
build_fts=0 ; cfg_build_fts() { return $build_fts; } # default true
drop_fts=1  ; cfg_drop_fts()  { return $drop_fts; }  # default false

while [[ $# -gt 0 ]]; do
    case $1 in
        "--append")
            shift
            append=0   # true
            drop_fts=0
            ;;
        *)
            args+=("$1")
            shift
            ;;
    esac
done

require_bin duckdb

duckdb_dest="${args[0]}"
duckdb_dest_tmp="${duckdb_dest}.tmp"
# time_start=${args[0]:-"$(TZ=UTC date -I)T00:00:00"}
# time_stop=${args[1]:-"$(TZ=UTC date -I)T23:59:59"}

printf "%s starting build\n" "$(TZ=UTC date)"

# remove tmp database in case of previous failure
if [[ -f "$duckdb_dest_tmp" ]]; then
    rm "$duckdb_dest_tmp" &>/dev/null
fi

if cfg_append; then
    # ensure database to be appended to exists
    if ! [[ -f "$duckdb_dest" ]]; then
        printf "destination database for append not found: %s\n" "$duckdb_dest"
        exit 1
    fi

    # no temporary file
    duckdb_dest_tmp=$duckdb_dest
    printf "appending to database %s\n" "$duckdb_dest"
else
    printf "building new database %s\n" "$duckdb_dest"
fi

# iterate through sqlite files to import
for source_db in "${args[@]:1}"; do
    printf "%s ... " "$source_db"

    if ! build_from_sqlite "${duckdb_dest_tmp}" "${source_db}"; then
        printf "error\n"
        exit 1
    fi
    printf "ok\n"
done

if cfg_build_fts; then
    printf "implementing fts ... "
    if ! fts_index "${duckdb_dest_tmp}" true; then
        printf "error\n"
        exit 1
    fi
    printf "ok\n"
fi

if ! cfg_append; then
    printf "replacing database ... "
    if ! mv "${duckdb_dest_tmp}" "${duckdb_dest}"; then
        printf "error\n"
        exit 1
    fi
    printf "ok\n"
fi

printf "%s build complete\n" "$(TZ=UTC date)"
